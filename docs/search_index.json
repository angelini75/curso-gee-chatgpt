[["index.html", "Uso de Google Earth Engine asistido por ChatGPT para gestión de Recursos Naturales Capítulo 1 Acerca del libro", " Uso de Google Earth Engine asistido por ChatGPT para gestión de Recursos Naturales Dr. Marcos E. Angelini 2024-12-21 Capítulo 1 Acerca del libro Este curso está diseñado para enseñar el uso de Google Earth Engine (GEE), una plataforma basada en la nube, combinando análisis de teledetección con el poder de la inteligencia artificial a través de ChatGPT. Objetivos específicos Comprender los fundamentos de Google Earth Engine. Aprender los conceptos básicos de programación en JavaScript. Realizar análisis avanzados como: Detección de cambios (inundaciones, incendios). Clasificación supervisada. Análisis de fenómenos estacionales. Interpolación utilizando Random Forest. Utilizar ChatGPT para: Generar y corregir scripts en GEE. Resolver problemas comunes en teledetección. Estructura El curso está dividido en los siguientes capítulos: Introducción a Google Earth Engine y ChatGPT. Fundamentos de programación en JavaScript. Ingeniería de Prompts con ChatGPT. Aplicaciones prácticas de GEE: detección de cambios, clasificación supervisada, y más. Evaluación. Esperamos que este curso te proporcione las herramientas necesarias para integrar GEE y ChatGPT en tus proyectos de análisis geoespacial. "],["introducción.html", "Capítulo 2 Introducción 2.1 Google Earth Engine 2.2 Introducción a JavaScript 2.3 Introducción a ChatGPT", " Capítulo 2 Introducción 2.1 Google Earth Engine 2.1.1 ¿Qué es Google Earth Engine? Google Earth Engine (GEE) es una plataforma revolucionaria para el análisis y procesamiento de datos geoespaciales. Alojada en la nube, combina un vasto catálogo de datos satelitales con una infraestructura computacional diseñada para manejar cálculos a gran escala. Su propósito principal es permitir a investigadores, académicos y profesionales abordar desafíos complejos relacionados con el medio ambiente y la gestión de recursos naturales. Lo que hace único a GEE no es solo su capacidad para procesar terabytes de datos en segundos, sino también la accesibilidad que brinda. Desde un navegador web, puedes analizar datos históricos y actuales, crear visualizaciones interactivas y compartir tus resultados con un solo clic. Para comenzar a utilizar Google Earth Engine (GEE), es fundamental crear una cuenta y configurar un proyecto asociado. A continuación, se detallan los pasos necesarios: 2.1.2 Creación de una Cuenta en Google Earth Engine Accede a la Página de Registro: Visita la página oficial de registro de GEE: Inicia sesión con tu cuenta de Google. Completa el Formulario de Solicitud: Proporciona la información requerida, como tu nombre, organización y una breve descripción de cómo planeas utilizar GEE. Acepta los términos de servicio. Espera la Aprobación: Tras enviar la solicitud, recibirás un correo electrónico de confirmación una vez que tu cuenta haya sido aprobada. 2.1.3 Creación de un Proyecto en Google Earth Engine Una vez que tu cuenta esté activa, es recomendable crear un proyecto para organizar y gestionar tus recursos de manera eficiente. Accede a Google Earth Engine: Dirígete al Editor de Código de GEE e inicia sesión con tu cuenta aprobada. Crea un Proyecto en Google Cloud Platform (GCP): GEE utiliza proyectos de GCP para la gestión de recursos. Accede a Google Cloud Console. En el menú superior, selecciona o crea un nuevo proyecto: Haz clic en el selector de proyectos y luego en “Nuevo Proyecto”. Asigna un nombre al proyecto y, si es necesario, selecciona una organización o ubicación de facturación. Haz clic en “Crear” y espera a que se configure el proyecto. Asocia el Proyecto de GCP con GEE: En el Editor de Código de GEE, ve a la sección “Assets” (Activos). Haz clic en “Create a new asset” (Crear un nuevo activo) y selecciona “Cloud Project”. Ingresa el ID del proyecto de GCP que creaste previamente. Sigue las indicaciones para vincular ambos servicios. 2.1.4 Consideraciones Adicionales Permisos y Facturación: Asegúrate de que tu proyecto de GCP tenga la facturación habilitada, aunque GEE ofrece una cuota gratuita. Configura los permisos adecuados para controlar quién puede acceder y modificar tu proyecto. Organización de Recursos: Utiliza el proyecto para almacenar y gestionar tus scripts, datos y otros recursos relacionados con tus análisis en GEE. Para una guía visual y detallada sobre la creación de una cuenta en Google Earth Engine, puedes consultar el siguiente video: 2.1.5 Bondades de Google Earth Engine Escalabilidad sin precedentes: GEE permite analizar áreas tan pequeñas como una parcela agrícola o tan grandes como continentes enteros, sin preocuparte por la capacidad de tu computadora local. Biblioteca global de datos: Incluye imágenes de satélites como Landsat y Sentinel, modelos climáticos, mapas de uso del suelo y mucho más. Rapidez y eficiencia: Cálculos que podrían tardar horas en otras plataformas aquí se ejecutan en minutos, aprovechando la infraestructura de Google. Facilidad de colaboración: Todo análisis puede compartirse mediante scripts reproducibles, lo que fomenta la transparencia y la colaboración científica. 2.1.6 Partes esenciales de la plataforma Google Earth Engine (GEE) cuenta con una interfaz intuitiva y poderosa diseñada para facilitar el análisis de datos geoespaciales. A continuación, se destacan las partes esenciales que hacen de esta plataforma una herramienta indispensable para investigadores y profesionales. 2.1.6.1 Interfaz de Usuario La imagen 2.1 muestra la interfaz principal de Google Earth Engine. Esta incluye: Figure 2.1: Interfaz principal de Google Earth Engine. Panel de Scripts: Ubicado en la parte izquierda, donde puedes crear, organizar y acceder a tus scripts. Los scripts se guardan en la nube, lo que permite acceder a ellos desde cualquier dispositivo con conexión a internet. Editor de Código: Situado al centro de la pantalla, este es el espacio principal para escribir y ejecutar scripts en JavaScript. Los resultados de tus análisis se reflejan en tiempo real en el mapa. Consola: En el panel derecho, la consola permite inspeccionar resultados, visualizar salidas intermedias de tus scripts y depurar errores. Mapa Interactivo: La sección inferior muestra un mapa interactivo que permite visualizar datos satelitales, análisis y resultados generados. Incluye herramientas básicas como zoom, cambio de capas entre satélite y mapa base, y un inspector para obtener información detallada sobre ubicaciones específicas. 2.1.6.2 Catálogo de Datos El Catálogo de Datos de GEE proporciona acceso a una vasta biblioteca de conjuntos de datos globales, incluyendo: Imágenes Satelitales: Series temporales de Landsat, Sentinel y MODIS, ideales para monitoreo ambiental, análisis de cambios y modelado climático. Mapas Temáticos: Cobertura del suelo, elevación, datos climáticos y más. Datos Personalizados: Posibilidad de cargar tus propios datos vectoriales o ráster para análisis específicos. 2.1.6.3 API de Earth Engine GEE también ofrece una API en Python, que extiende sus capacidades al integrarse en flujos de trabajo personalizados. Esto permite combinar la potencia de GEE con bibliotecas como pandas y matplotlib para análisis y visualizaciones adicionales. 2.1.6.4 Visualización Interactiva La combinación del editor de código y el mapa interactivo permite generar visualizaciones en tiempo real. Estas herramientas no solo son útiles para analizar datos, sino también para comunicar resultados de manera efectiva. 2.1.7 ¿Por qué es importante esta plataforma? La interfaz y las herramientas integradas en Google Earth Engine hacen que sea accesible para usuarios con diferentes niveles de experiencia. Desde investigadores académicos hasta gestores ambientales, GEE reduce las barreras técnicas al análisis de grandes volúmenes de datos espaciales, todo desde un navegador web. 2.1.8 Condiciones de uso GEE está disponible de forma gratuita para fines académicos y no comerciales. Sin embargo, requiere un registro previo y aprobación. Al registrarte, se espera que describas brevemente tu propósito de uso. Aunque la plataforma es accesible, existen ciertos límites en el procesamiento y la descarga de datos, diseñados para garantizar un uso justo. 2.1.9 Ejemplo de las capacidades de GEE Una de las características más destacadas de GEE es su capacidad para analizar grandes volúmenes de datos históricos. Por ejemplo, un estudio podría explorar cómo ha cambiado la cobertura forestal en los últimos 30 años utilizando imágenes Landsat. A través de funciones integradas, como la creación de índices de vegetación (NDVI), es posible identificar áreas donde la deforestación ha avanzado o incluso mapear patrones de regeneración natural. 2.2 Introducción a JavaScript JavaScript es el lenguaje principal utilizado en Google Earth Engine (GEE). Si nunca has trabajado con un lenguaje de programación, no te preocupes. A continuación, exploraremos los elementos básicos de JavaScript, cómo identificarlos visualmente en el Editor de Código de GEE y cómo entender la estructura de un script. 2.2.1 Elementos básicos de un script de JavaScript Cuando escribes un script en JavaScript, estás combinando varios elementos que trabajan juntos para procesar datos y realizar tareas. Aquí te explicamos los componentes clave: La imagen 2.2 muestra el script de la manera que se vería en GEE. Figure 2.2: Script de Google Earth Engine. Variables Qué son: Las variables almacenan datos, como números, texto o resultados de operaciones. Cómo se declaran: Usamos la palabra clave var. Cómo se ven en GEE: Aparecen en color negro en el Editor de Código. Ejemplo: var x = 5; // x almacena el número 5 var texto = &quot;Hola mundo&quot;; // texto almacena una cadena de texto Funciones Qué son: Bloques de código que realizan una tarea específica y pueden reutilizarse. Cómo se ven en GEE: Aparecen en color negro cuando las defines, y en color violeta cuando usas funciones predefinidas de GEE. Ejemplo: function saludar(nombre) { return &quot;Hola, &quot; + nombre; // Esta función retorna un saludo personalizado } Operadores Qué son: Símbolos que realizan operaciones entre valores, como + (suma) o = (asignación). Cómo se ven en GEE: En color negro y texto en negrita. Ejemplo: var suma = 5 + 3; // El resultado es 8 Comentarios Qué son: Notas en el código que no se ejecutan pero ayudan a explicar lo que hace el script. Cómo se ven en GEE: En verde. Ejemplo: // Este es un comentario de una línea Numeros y textos Qué son: son los valores que requieren los argumentos de las funciones. Cómo se ven en GEE: Números se ven azul y valores alfanuméricos se ven en rojo. Ejemplo: var a = [&#39;B8A&#39;, &#39;B4&#39;] var b = 5 2.2.2 Entendiendo la sintaxis en JavaScript y Google Earth Engine Antes de trabajar con un script en Google Earth Engine (GEE), es importante entender cómo está estructurada la sintaxis y qué significan los diferentes elementos que la componen. En esencia, un script es una serie de instrucciones que la computadora ejecuta secuencialmente, y en GEE estas instrucciones están diseñadas para trabajar con datos geoespaciales. 2.2.3 Elementos clave de la sintaxis Variables: Las variables son contenedores donde almacenamos datos o referencias a objetos. En JavaScript, usamos la palabra clave var para declararlas. Por ejemplo: var areaInteres = ee.Geometry.Point([-58.3816, -34.6037]); Aquí, areaInteres es una variable que contiene un punto geográfico (una coordenada). Funciones: Las funciones son bloques de código que realizan una tarea específica. Algunas funciones están predefinidas en GEE, como ee.Geometry.Point, mientras que otras pueden ser definidas por el usuario. var ndvi = imagenLandsat.normalizedDifference([&#39;SR_B5&#39;, &#39;SR_B4&#39;]); En este caso, normalizedDifference es una función que calcula un índice NDVI usando dos bandas de la imagen. Puntos (.): En JavaScript y GEE, el punto se utiliza para acceder a propiedades o métodos de un objeto. Por ejemplo: ee.ImageCollection(&quot;LANDSAT/LC08/C02/T1_L2&quot;).filterBounds(areaInteres); Aquí, filterBounds es un método aplicado al objeto ee.ImageCollection. Paréntesis (()): Los paréntesis se utilizan para ejecutar funciones o métodos. Dentro de los paréntesis, podemos pasar argumentos que especifican cómo se debe ejecutar la función. Por ejemplo: Map.centerObject(areaInteres, 10); La función centerObject toma dos argumentos: un objeto geográfico y un nivel de zoom. Corchetes ([]): Los corchetes se usan para trabajar con listas o conjuntos de datos. Por ejemplo: [&#39;SR_B5&#39;, &#39;SR_B4&#39;]; Este conjunto de bandas indica las bandas que se usarán para calcular el NDVI. Llaves ({}): Las llaves se usan para definir bloques de código (como en funciones) o para especificar opciones dentro de un método. Por ejemplo: {bands: [&#39;SR_B4&#39;, &#39;SR_B3&#39;, &#39;SR_B2&#39;], min: 0, max: 3000}; Este bloque especifica las bandas y los rangos para visualizar una imagen en color verdadero. Comentarios (//): Los comentarios son líneas de texto que no se ejecutan. Se utilizan para explicar el código y facilitar su comprensión. // Este es un comentario. 2.2.4 Cómo leer un script La clave para entender un script es identificar la secuencia lógica de sus elementos: Define variables: Aquí se almacenan los datos o configuraciones necesarias para el análisis. Aplica funciones y métodos: Estas instrucciones procesan los datos almacenados en las variables. Agrega visualizaciones: Finalmente, los resultados del análisis se muestran en el mapa. 2.2.5 Ejemplo básico desglosado Tomemos esta línea de código como ejemplo: var ndvi = imagenLandsat.normalizedDifference([&#39;SR_B5&#39;, &#39;SR_B4&#39;]).rename(&#39;NDVI&#39;); imagenLandsat: Es una variable que contiene una imagen satelital. normalizedDifference: Es un método que calcula la diferencia normalizada entre las bandas SR_B5 y SR_B4. rename: Cambia el nombre de la banda resultante a 'NDVI'. ndvi: Es la variable donde se almacena el resultado. 2.2.6 El uso de la función print En Google Earth Engine (GEE), la función print es una herramienta muy útil para entender y depurar tu código, especialmente si estás empezando a programar. Su propósito principal es mostrar información en la consola del editor de código para que puedas verificar que los datos o las operaciones están funcionando como esperas. 2.2.6.0.1 Cómo usar print La sintaxis básica de print es la siguiente: print(nombreVariable, &#39;Descripción opcional&#39;); nombreVariable: Es el objeto o valor que deseas inspeccionar. Descripción opcional: Es un texto que ayuda a identificar qué se está mostrando en la consola (no es obligatorio, pero es recomendable). 2.2.6.1 Ejemplo de uso Supongamos que quieres asegurarte de que la imagen de Landsat seleccionada cumple con el filtro de nubosidad aplicado. Puedes usar print para mostrar la imagen y explorar sus propiedades: // Verificar la imagen seleccionada print(imagenLandsat, &#39;Primera imagen de la colección filtrada&#39;); Esto mostrará información sobre imagenLandsat en la consola, como su fecha de adquisición, las bandas disponibles y los metadatos asociados. También puedes imprimir otros objetos como geometrías, colecciones de imágenes o valores calculados. 2.2.6.2 Depurando con print Si estás calculando el NDVI, puedes verificar que el resultado es correcto imprimiendo el objeto resultante: // Verificar el cálculo del NDVI print(ndvi, &#39;NDVI calculado&#39;); Esto te permite inspeccionar las propiedades del NDVI y confirmar que la banda fue calculada correctamente. 2.2.6.3 ¿Por qué es útil para principiantes? Comprensión de objetos: Si no estás seguro de cómo es un objeto en GEE (como una imagen, una colección o un valor escalar), print te permite explorarlo visualmente. Rastreo de errores: Si algo no funciona en tu script, puedes usar print en diferentes partes del código para verificar dónde se produce el error. Validación paso a paso: print ayuda a validar que cada paso del análisis está generando los resultados esperados antes de continuar con los pasos siguientes. Exploración de datos: Con print, puedes inspeccionar propiedades de las imágenes o colecciones, como las bandas disponibles, los rangos de valores y los metadatos. 2.2.6.4 Consejo para usar print eficientemente Aunque es útil, evita abusar de print en scripts largos o complejos, ya que puede generar demasiada información en la consola. Usa descripciones claras para cada línea de print y borra las que ya no necesites una vez que hayas validado tu código. 2.2.7 Un primer script en Google Earth Engine Este script simple en Google Earth Engine carga una colección de imágenes Landsat 8, filtra aquellas con menos del 20% de nubosidad, selecciona la primera imagen disponible, calcula el NDVI y visualiza tanto la imagen original como el NDVI en el mapa. // Definir el área de interés: Buenos Aires var areaInteres = ee.Geometry.Point([-58.3816, -34.6037]); // Cargar la colección de imágenes Landsat 8 var coleccionLandsat = ee.ImageCollection(&quot;LANDSAT/LC08/C02/T1_L2&quot;) .filterBounds(areaInteres) // Filtrar por ubicación .filter(ee.Filter.lt(&#39;CLOUD_COVER&#39;, 20)) // Filtrar imágenes con menos del 20% de nubosidad .sort(&#39;CLOUD_COVER&#39;); // Ordenar por porcentaje de nubosidad ascendente // Seleccionar la primera imagen de la colección filtrada var imagenLandsat = coleccionLandsat.first(); // Calcular el NDVI var ndvi = imagenLandsat.normalizedDifference([&#39;SR_B5&#39;, &#39;SR_B4&#39;]).rename(&#39;NDVI&#39;); // Centrar el mapa en el área de interés Map.centerObject(areaInteres, 10); // Añadir el NDVI al mapa Map.addLayer(ndvi, {min: -0.1, max: 0.4, palette: [&#39;blue&#39;, &#39;brown&#39;, &#39;yellow&#39;, &#39;green&#39;]}, &#39;NDVI&#39;); Figure 2.3: Captura de pantalla del script. 2.2.7.1 Analizando el script Comentarios: Las líneas que comienzan con // explican lo que hace cada parte del código. Estas no son ejecutadas y ayudan a comprender el propósito de cada sección. Variables: areaInteres: Define un punto geográfico que representa a Buenos Aires. coleccionLandsat: Contiene la colección de imágenes Landsat 8 que cumplen con los filtros aplicados. imagenLandsat: La primera imagen de la colección filtrada. ndvi: Almacena el resultado del cálculo del Índice de Vegetación de Diferencia Normalizada (NDVI). Funciones y métodos: ee.Geometry.Point: Crea un punto geográfico para definir el área de interés. filterBounds: Filtra imágenes que cubren el área de interés. filter: Filtra imágenes con menos del 20% de nubosidad según la propiedad CLOUD_COVER. sort: Ordena las imágenes por el porcentaje de nubosidad en orden ascendente. normalizedDifference: Calcula el NDVI utilizando las bandas 'SR_B5' (infrarrojo cercano) y 'SR_B4' (rojo). rename: Renombra la banda generada como 'NDVI'. Map.centerObject: Centra el mapa en el área de interés. Map.addLayer: Añade una capa visual al mapa. Visualización interactiva: RGB: Utiliza las bandas 'SR_B4', 'SR_B3' y 'SR_B2' para generar una visualización en color verdadero. NDVI: Representa los valores del NDVI con una paleta de colores que varía de azul (bajos valores de NDVI) a verde (altos valores de NDVI). 2.2.7.2 Colores en el Editor de Código de GEE Negro: Variables como coleccionLandsat y ndvi. Violeta: Métodos y funciones predefinidas como filterBounds, normalizedDifference y addLayer. Negro: Funciones definidas por el usuario (en este caso, no se utilizan). Verde: Comentarios que explican el código. Negro en negrita: Operadores como = para asignaciones. 2.2.8 Pregunta para el lector ¿Qué resultado obtendrías si cambias el filtro de nubosidad (CLOUD_COVER) al 50%? ¿Cómo impactaría esto en la calidad visual de las imágenes seleccionadas? 2.2.9 Ejercicio Entendido. Vamos a simplificar el ejercicio y proporcionar fragmentos de código con partes faltantes para que los estudiantes los completen. A continuación, se detallan los pasos básicos para crear un script en Google Earth Engine (GEE): 2.2.9.1 Pasos para crear un script en GEE Definir el Área de Interés (AOI): Utiliza las herramientas de dibujo en el Editor de Código de GEE para delinear tu área de interés. Alternativamente, puedes definir el AOI programáticamente utilizando coordenadas geográficas. Seleccionar una Colección de Datos: Accede al Catálogo de Datos de GEE para explorar las colecciones disponibles. Selecciona una colección que se ajuste a tus necesidades, como imágenes satelitales recientes. Filtrar la Colección por el Área de Interés y Fecha: Aplica filtros espaciales y temporales para restringir la colección a tu AOI y al período de tiempo deseado. Obtener la Imagen Más Reciente: Ordena la colección filtrada por fecha de adquisición en orden descendente. Selecciona la primera imagen de la colección ordenada, que corresponderá a la más reciente. Visualizar la Imagen en el Mapa: Añade la imagen seleccionada al mapa utilizando parámetros de visualización adecuados. 2.2.9.2 Fragmentos de código para completar A continuación, se proporcionan fragmentos de código con partes faltantes que deberás completar: // 1. Definir el Área de Interés (AOI) // Completa la línea siguiente para definir un punto de coordenadas var aoi = ee.Geometry.Point([/* longitud */, /* latitud */]); // 2. Seleccionar una Colección de Datos // Completa con el ID de la colección deseada var collection = ee.ImageCollection(&#39;/* ID de la colección */&#39;); // 3. Filtrar la Colección por el Área de Interés y Fecha // Completa con las fechas de inicio y fin en formato &#39;YYYY-MM-DD&#39; var filteredCollection = collection .filterBounds(aoi) .filterDate(&#39;/* fecha de inicio */&#39;, &#39;/* fecha de fin */&#39;); // 4. Obtener la Imagen Más Reciente // Completa para ordenar por fecha en orden descendente y seleccionar la primera imagen var latestImage = filteredCollection .sort(&#39;system:time_start&#39;, /* orden descendente */) .first(); // 5. Visualizar la Imagen en el Mapa // Completa para centrar el mapa en el AOI con un nivel de zoom adecuado Map.centerObject(aoi, /* nivel de zoom */); // Completa con las bandas y parámetros de visualización adecuados Map.addLayer(latestImage, {bands: [/* bandas */], min: /* valor mínimo */, max: /* valor máximo */}, &#39;Imagen más reciente&#39;); 2.2.9.3 Indicaciones para completar los fragmentos Definir el AOI: Sustituye /* longitud */ y /* latitud */ por las coordenadas numéricas correspondientes a tu área de interés. Seleccionar la Colección de Datos: Reemplaza '/* ID de la colección */' con el ID de la colección de datos que deseas utilizar. Por ejemplo, para Landsat 8 Collection 2, Nivel 2, el ID es 'LANDSAT/LC08/C02/T1_L2'. Filtrar la Colección por Fecha: Sustituye '/* fecha de inicio */' y '/* fecha de fin */' por las fechas deseadas en formato 'YYYY-MM-DD'. Obtener la Imagen Más Reciente: Para ordenar en orden descendente, utiliza false en /* orden descendente */. Visualizar la Imagen en el Mapa: Sustituye /* nivel de zoom */ por un número que represente el nivel de acercamiento deseado (por ejemplo, 10). Reemplaza /* bandas */ con las bandas que deseas visualizar (por ejemplo, ['SR_B4', 'SR_B3', 'SR_B2'] para una imagen en color verdadero). Sustituye /* valor mínimo */ y /* valor máximo */ por los valores de visualización adecuados para las bandas seleccionadas (por ejemplo, 0 y 3000, respectivamente). 2.2.9.4 Recursos adicionales Para ayudarte a completar estos fragmentos de código, puedes consultar los siguientes recursos: Tutoriales de Google Earth Engine: Introducción a la API de JavaScript de Earth Engine Recopilatorio de scripts para Google Earth Engine: Gis&amp;Beers - Scripts para Google Earth Engine 2.3 Introducción a ChatGPT Aprender un nuevo lenguaje de programación puede ser un desafío significativo. La curva de aprendizaje es pronunciada y dominar herramientas como Google Earth Engine (GEE) requiere tiempo y práctica. Sin embargo, los Grandes Modelos de Lenguaje (LLM, por sus siglas en inglés) pueden ser aliados valiosos en este proceso. 2.3.1 ¿Qué son los Grandes Modelos de Lenguaje (LLM)? Los Grandes Modelos de Lenguaje (LLM, por sus siglas en inglés), son sistemas avanzados de inteligencia artificial diseñados para procesar y generar lenguaje humano con gran precisión. Estos modelos, entrenados con enormes volúmenes de texto, pueden llevar a cabo tareas que van desde la generación de contenido hasta el soporte en actividades técnicas complejas, como la programación. Entre los LLM más conocidos se encuentra ChatGPT, desarrollado por OpenAI, una herramienta que destaca por su capacidad para mantener conversaciones, proporcionar explicaciones detalladas y asistir en la resolución de problemas. Para aprovechar al máximo las capacidades de ChatGPT en tus proyectos de programación, es fundamental crear una cuenta y familiarizarte con su interfaz gráfica. A continuación, te proporcionamos una guía paso a paso para registrarte y una breve descripción de la interfaz de usuario. 2.3.2 Creación de una Cuenta en ChatGPT Accede al Sitio Web Oficial: Dirígete a chat.openai.com. Registro: Haz clic en “Sign Up” (Registrarse). Proporciona tu Correo Electrónico: Ingresa una dirección de correo electrónico válida y crea una contraseña segura. Verificación: Revisa tu correo electrónico y sigue el enlace de verificación enviado por OpenAI. Completa tu Perfil: Una vez verificada tu cuenta, proporciona la información adicional solicitada para completar tu perfil. 2.3.3 Explorando la Interfaz de ChatGPT Una vez que hayas iniciado sesión, te encontrarás con una interfaz sencilla y funcional como la de la figura 2.4: Figure 2.4: Interfaz principal de ChatGPT. Barra de Navegación Superior: Incluye opciones como “New Chat” para iniciar una nueva conversación y un menú desplegable para acceder a tu cuenta y configuraciones. Área Principal de Conversación: Aquí se muestran tus interacciones con ChatGPT. Las respuestas del modelo aparecen en burbujas de texto, facilitando la lectura y seguimiento de la conversación. Campo de Entrada de Texto: Ubicado en la parte inferior, permite escribir tus consultas o prompts. Una vez redactada tu pregunta, presiona “Enter” o haz clic en el botón de envío para recibir una respuesta. Historial de Conversaciones: En el panel lateral izquierdo, puedes acceder a tus conversaciones anteriores, lo que facilita retomar discusiones o revisar información proporcionada previamente. Familiarizarte con esta interfaz te permitirá interactuar de manera más eficiente con ChatGPT, optimizando tu experiencia en el desarrollo de proyectos de programación y otras tareas. 2.3.3.1 Aplicaciones de ChatGPT en Programación ChatGPT ha demostrado ser una herramienta versátil y eficaz en el ámbito de la programación, ofreciendo una amplia variedad de funcionalidades que simplifican y optimizan el proceso de desarrollo de software: Generación de Código: A partir de una descripción en lenguaje natural, ChatGPT puede generar fragmentos de código funcionales, ayudando a materializar ideas rápidamente. Depuración y Diagnóstico de Errores: Identifica errores en el código y sugiere correcciones detalladas, facilitando la depuración incluso para quienes están aprendiendo. Conversión entre Lenguajes de Programación: Traduce código de un lenguaje a otro, permitiendo a los desarrolladores trabajar de manera más eficiente en entornos multiplataforma. Optimización de Código: Sugiere mejoras para hacer que el código sea más eficiente, legible y rápido. Exploración de Nuevas Tecnologías: Proporciona guías y explicaciones claras sobre conceptos o herramientas que un usuario está aprendiendo, desglosando la información en pasos manejables. Es crucial recordar que, aunque ChatGPT es extremadamente útil, su asistencia no reemplaza la necesidad de comprender los fundamentos de la programación. El usuario debe revisar críticamente las soluciones sugeridas para garantizar que sean precisas y relevantes para su contexto. 2.3.3.2 Utilidad de ChatGPT en el Contexto de este Curso En el marco del aprendizaje de Google Earth Engine (GEE), ChatGPT se convierte en un aliado indispensable, especialmente para quienes están comenzando a trabajar con JavaScript o con GEE. Sus aplicaciones específicas incluyen: Soporte en Escritura de Código: ChatGPT puede generar ejemplos y explicar fragmentos de código en JavaScript relacionados con GEE, ayudando a comprender cómo interactuar con la plataforma. Resolución de Conceptos Complejos: Facilita la comprensión de temas avanzados al responder preguntas relacionadas con la funcionalidad de GEE y su aplicación. Recomendaciones para Mejorar el Trabajo: Proporciona consejos prácticos sobre cómo estructurar y optimizar scripts, asegurando que el código sea eficiente y claro. Con estas herramientas, ChatGPT no solo acelera el aprendizaje, sino que también actúa como un recurso constante para superar obstáculos técnicos a lo largo del curso. Entendido. Aquí tienes la versión actualizada con títulos y subtítulos claros, sin los asteriscos, y con un uso más moderado de los bullet points. 2.3.4 Ingeniería de Prompts La ingeniería de prompts es el arte de formular preguntas efectivas para obtener respuestas precisas y útiles de los Grandes Modelos de Lenguaje (LLM) como ChatGPT. Aunque parece sencillo, el verdadero desafío radica en estructurar el flujo de trabajo de manera eficiente para que las respuestas se adapten exactamente a tus necesidades. Esta sección se enfoca en la forma más eficaz de utilizar ChatGPT en el contexto de Google Earth Engine (GEE) y JavaScript. ATENCION! Usa los prompts de ejemplos que se dan en las siguientes subsecciones en ChatGPT y observa los resultados, al final hay algunas preguntas al respecto. 2.3.4.1 Claridad y especificidad Cuanto más claro y específico sea tu prompt, más precisa será la respuesta. Evita los términos generales y proporciona instrucciones concretas. Ejemplo de mala formulación del prompt: Explícame GEE. Problemas: - No se sabe qué aspecto de GEE se desea comprender (¿la plataforma? ¿su arquitectura? ¿un concepto específico?). - La respuesta puede ser demasiado general. Ejemplo de buena formulación del prompt: Explícame la diferencia entre `ee.ImageCollection` y `ee.Image` en Google Earth Engine, con ejemplos de uso. Razones por las que es un buen prompt: - Delimita claramente el tema de la consulta: “diferencia entre ee.ImageCollection y ee.Image”. - Se solicita una explicación con ejemplos, lo que hace la respuesta más valiosa. 2.3.4.2 Estrategias de Contexto y Formato Para que ChatGPT entienda mejor la consulta, incluye información de fondo que permita al modelo responder de forma más específica. Ejemplo sin contexto: Corrige este código: var imagen = ee.ImageCollection(&quot;Landsat&quot;); Problemas: - No se especifica qué se espera corregir (¿errores de sintaxis, lógica, eficiencia?). - La colección “Landsat” no es válida en GEE. El ID correcto sería ‘LANDSAT/LC08/C02/T1_L2’. Ejemplo con contexto: Este código lanza un error en Google Earth Engine. Necesito que lo corrijas y me expliques la razón del error. El objetivo es cargar imágenes de Landsat 8 y calcular el NDVI. Aquí está el código: var imagen = ee.ImageCollection(&quot;Landsat&quot;); print(imagen) ImageCollection (Error) ImageCollection.load: ImageCollection asset &#39;Landsat&#39; not found (does not exist or caller does not have access). Razones por las que es un buen prompt: - Se da contexto sobre el objetivo (“calcular NDVI de Landsat 8”). - Se solicita no solo la corrección, sino que se incluye el error obtenido en la consola de GEE. 2.3.4.3 Definir el formato de la respuesta Indicar el formato en el que deseas la respuesta es esencial para evitar respuestas largas o poco claras. Técnicas para definir el formato: - Solicitar listas estructuradas: Dame una lista de los pasos para calcular el NDVI en GEE. Especificar el formato de la respuesta: Explica la diferencia entre `ee.ImageCollection` y `ee.Image` en Google Earth Engine. Responde en formato de tabla con dos columnas: &#39;Concepto&#39; y &#39;Diferencia&#39;. Indicar la longitud máxima de la respuesta: Explica la diferencia entre `Map.addLayer` y `Map.centerObject` en GEE en menos de 50 palabras. Ejemplo solicitando un formato de lista: Enumera 5 buenas prácticas para escribir scripts eficientes en Google Earth Engine. Ejemplo solicitando un formato de tabla: Explica la diferencia entre `Map.addLayer` y `Map.centerObject` en Google Earth Engine en una tabla con dos columnas: &#39;Función&#39; y &#39;Descripción&#39;. 2.3.4.4 Iteración y Refinamiento del Prompt Si la respuesta inicial no es la esperada, no te frustres. Ajusta el prompt para hacerlo más preciso. Pasos para refinar un prompt: 1. Identifica lo que falta en la respuesta. 2. Especifica el formato, el contexto o la claridad de la respuesta. 3. Evita generalidades y usa palabras clave precisas. Ejemplo de iteración de un prompt: Primer intento (demasiado general): Explícame los errores en este código de GEE. Iteración 1 (agregando contexto): Este código me da el error &quot;Unknown function &#39;normalizedDifference&#39;&quot;. ¿Qué está mal? var imagen = ee.ImageCollection(&quot;Landsat&quot;).normalizedDifference([&#39;B5&#39;, &#39;B4&#39;]); Iteración 2 (especificando formato y objetivo): Explica el error en el siguiente código y proporciona una versión corregida. Justifica la corrección. var imagen = ee.ImageCollection(&quot;Landsat&quot;).normalizedDifference([&#39;B5&#39;, &#39;B4&#39;]); print(imagen) Line 1: ee.ImageCollection(...).normalizedDifference is not a function 2.3.4.5 Flujo de Trabajo para la Ingeniería de Prompts Conseguir respuestas satisfactorias de ChatGPT requiere de simultaneas interacciones con el modelo, sobre todo cuando el problema que necesitamos resolver es complejo. Aquí hay algunos pasos que te pueden servir para obtener soluciones a problemas complejos: Divide el problema en partes pequeñas. En lugar de pedir la solución completa de un problema, solicita partes individuales. Ejemplo: Primero pide “cómo cargar imágenes”, luego “cómo calcular NDVI”, y finalmente “cómo visualizar el resultado”. Solicita ejemplos concretos de código. Pide “un ejemplo práctico” para asegurarte de que la explicación te permita ver el uso real. Ejemplo: Muéstrame un ejemplo de cómo calcular el NDVI usando la colección Landsat 8 en Google Earth Engine. Pide explicaciones paso a paso. Si no comprendes una respuesta, solicita una “explicación paso a paso”. Este paso es esencial si lo que quieres es aprender GEE. Ejemplo: Explícame paso a paso cómo funciona la función `normalizedDifference` en Google Earth Engine. Solicita recomendaciones de buenas prácticas. Pregunta por buenas prácticas para optimizar tu flujo de trabajo. Ejemplo: ¿Cuáles son las mejores prácticas para optimizar el rendimiento de un script en Google Earth Engine? Explica el objetivo final. Explica a ChatGPT tu objetivo final. Esto le permite generar respuestas más relevantes. Ejemplo: Necesito calcular el NDVI para detectar cambios en la vegetación entre dos fechas específicas usando GEE. ¿Cómo debería estructurar mi script? 2.3.4.6 Trucos Avanzados en ChatGPT A medida que adquieres experiencia con ChatGPT, te darás cuenta de que la forma en que se formula una consulta puede influir significativamente en la calidad de la respuesta. Los trucos avanzados permiten aprovechar al máximo las capacidades del modelo, ayudándote a obtener respuestas más precisas, personalizadas y útiles. Estos trucos se basan en comprender cómo funciona un modelo de lenguaje. ChatGPT no “piensa”, pero responde en función de patrones de lenguaje y contexto. Si le proporcionas un contexto más claro, ejemplos específicos o estructuras definidas, el modelo puede ofrecer respuestas mucho más acertadas. Los trucos te permiten controlar el formato, el tono y la precisión de la respuesta, facilitando la interacción con la herramienta. A continuación, se presentan algunas técnicas avanzadas para mejorar la interacción con ChatGPT, especialmente en el contexto de Google Earth Engine (GEE) y JavaScript. Utilizar “Personas” o “Roles”: Actúa como un experto en teledetección y explícame cómo usar `filterBounds` y `filterDate` en GEE. Forzar la salida de la respuesta en formato de código: Genera un script en JavaScript para GEE que calcule el NDVI y lo visualice en el mapa. Solo dame el código sin explicaciones. Solicitar múltiples opciones: Dame 3 formas de optimizar la eficiencia de un script en GEE. Controlar el tono o estilo de la respuesta: Explica el concepto de &quot;Map.centerObject&quot; en GEE como si le estuvieras hablando a un niño de 10 años. 2.3.5 Preguntas al lector Responde las preguntas a continuación y al finalizar haz clic en Submit. Luego revisa el score para ver si las respuesta fueron correctas Loading… "],["análisis-multitemporal-para-la-detección-de-cambios.html", "Capítulo 3 Análisis multitemporal para la detección de cambios 3.1 Pasos para el análisis multitemporal 3.2 Análisis multitemporal de incendios en Córdoba (2020) usando ChatGPT y Google Earth Engine", " Capítulo 3 Análisis multitemporal para la detección de cambios El análisis multitemporal en Google Earth Engine (GEE) permite estudiar cómo evolucionan las características de una región a lo largo del tiempo utilizando imágenes satelitales capturadas en diferentes fechas. Esta técnica es fundamental para monitorear fenómenos como la deforestación, el avance urbano, los incendios forestales o las inundaciones. Al integrar este tipo de análisis en GEE, los usuarios pueden automatizar procesos y manejar grandes volúmenes de datos satelitales de forma eficiente. A continuación, se describen los pasos esenciales para realizar un análisis multitemporal, integrando tanto la teoría subyacente como la práctica para que puedas aplicarlos de forma efectiva. 3.1 Pasos para el análisis multitemporal 3.1.1 1. Definir la región de interés (ROI) El primer paso para cualquier análisis geoespacial es definir la región de interés (ROI, por sus siglas en inglés). Esta región establece el área geográfica donde se concentrará el análisis y delimita el espacio que se analizará en cada imagen satelital. Definir la ROI correctamente es esencial para optimizar el rendimiento computacional, ya que permite reducir el volumen de datos procesados. Para definir la ROI, puedes optar por distintas estrategias. Por un lado, puedes dibujar la región directamente en el editor de GEE utilizando las herramientas de dibujo (polígonos, puntos o rectángulos). Por otro lado, si ya cuentas con archivos de formato Shapefile o GeoJSON, puedes importarlos y usarlos como referencia para la región de estudio. Las coordenadas también se pueden definir manualmente si tienes puntos específicos en mente. Desde el punto de vista teórico, la ROI establece los límites espaciales del análisis, lo que significa que solo los píxeles dentro de esta región serán procesados. Esto mejora la eficiencia computacional y permite focalizar los recursos de procesamiento en el área relevante. 3.1.2 2. Seleccionar las colecciones de imágenes adecuadas Una vez que se ha definido la región, se deben seleccionar las colecciones de imágenes satelitales adecuadas. Las imágenes deben cubrir el período de tiempo que se desea analizar y, además, deben ser apropiadas para los objetivos del análisis. Los conjuntos de datos más utilizados en GEE incluyen las colecciones de Landsat, Sentinel-2 y MODIS. La elección de la colección de imágenes depende del fenómeno a estudiar. Por ejemplo, para la detección de cambios en la vegetación, el NDVI (Índice de Vegetación de Diferencia Normalizada) suele calcularse a partir de las bandas de infrarrojo cercano y rojo, que están presentes tanto en Landsat como en Sentinel. Si se busca mayor resolución temporal, se prefiere Sentinel-2, ya que ofrece imágenes cada 5 días, mientras que Landsat solo captura imágenes cada 16 días. Desde una perspectiva teórica, la disponibilidad de una amplia colección de imágenes garantiza la posibilidad de realizar un análisis preciso. También es fundamental considerar la cobertura de nubes de la colección seleccionada, ya que la nubosidad puede dificultar la observación de la superficie terrestre. 3.1.3 3. Aplicar filtros temporales y espaciales Con la colección de imágenes seleccionada, se deben aplicar filtros para reducir el volumen de imágenes a las fechas y áreas de interés. Este proceso implica dos acciones clave: filtrar por rango de fechas y por región de interés. El filtro de fechas permite seleccionar imágenes dentro de un rango temporal específico. Este paso es esencial para realizar comparaciones antes y después de eventos como incendios o inundaciones. Por ejemplo, si se desea estudiar la deforestación entre 2018 y 2022, se puede aplicar un filtro de fechas que permita extraer solo las imágenes de esos años. El filtro espacial asegura que solo se utilicen imágenes que intersecten la región de interés (ROI). De esta forma, se evitan imágenes innecesarias de regiones distantes que no aportan valor al análisis. Esta etapa es clave para reducir el tamaño de los datos y acelerar el procesamiento. Teóricamente, los filtros temporales y espaciales garantizan que solo se procesen los datos que realmente importan. Además, estos filtros reducen la carga de procesamiento computacional, permitiendo una ejecución más eficiente y rápida. 3.1.4 4. Preprocesamiento de las imágenes El preprocesamiento de imágenes es esencial para asegurar la calidad y precisión de los datos antes de aplicar cualquier tipo de análisis. Este paso permite corregir posibles errores o distorsiones en las imágenes satelitales, asegurando que los resultados no estén contaminados por elementos indeseados. El preprocesamiento puede incluir la corrección atmosférica, que se utiliza para eliminar los efectos de la atmósfera (como neblina o aerosoles) en la reflectancia de la superficie. Este paso es crucial para realizar comparaciones multitemporales, ya que las variaciones en la atmósfera pueden hacer que una imagen parezca diferente a otra, incluso si no ha habido ningún cambio real en la superficie. Otra tarea importante del preprocesamiento es la eliminación de nubes y sombras. Las nubes pueden bloquear la vista de la superficie terrestre, mientras que las sombras proyectadas por estas nubes pueden introducir errores en los análisis. Las imágenes de las colecciones Sentinel y Landsat suelen incluir máscaras de nubes que permiten ocultarlas automáticamente. 3.1.5 5. Calcular índices o métricas relevantes Para visualizar y cuantificar los cambios en la superficie terrestre, es común calcular índices o métricas que resuman la información contenida en las bandas espectrales. Los índices de vegetación, agua o suelo son los más utilizados en teledetección. El NDVI (Índice de Vegetación de Diferencia Normalizada) es uno de los índices más comunes. Se calcula combinando la banda de infrarrojo cercano (NIR) y la banda roja (Red), y permite detectar la presencia de vegetación viva. Este índice varía entre -1 y 1, donde valores altos indican vegetación densa y valores bajos representan suelos desnudos o cuerpos de agua. Otros índices relevantes incluyen el NDWI (índice de agua) y el NDSI (índice de nieve). Cada uno de estos índices resalta características específicas de la superficie, lo que facilita la identificación de cambios a lo largo del tiempo. 3.1.6 6. Generar composiciones temporales La creación de composiciones temporales permite observar los cambios visualmente. Estas composiciones se pueden realizar asignando diferentes fechas a cada canal de color (rojo, verde y azul) para representar de forma gráfica los cambios entre imágenes. Por ejemplo, se puede asignar una imagen de enero a la banda roja, una de mayo a la banda verde y una de septiembre a la banda azul. Esta técnica permite detectar cambios fácilmente, ya que las diferencias de color reflejan la variación en la cobertura del suelo. Si la vegetación ha desaparecido entre enero y septiembre, la banda verde perderá intensidad, mientras que los otros canales se mantendrán constantes. Desde una perspectiva teórica, esta técnica permite representar el cambio de forma intuitiva y visual, facilitando la identificación de áreas donde se han producido alteraciones significativas. 3.1.7 7. Analizar y visualizar los resultados En esta etapa, se analizan los resultados obtenidos y se visualizan de forma clara e interpretativa. Los cambios pueden representarse con mapas temáticos que indiquen, por ejemplo, la pérdida de cobertura forestal o la expansión de áreas urbanas. Las gráficas de series temporales son otra forma de visualizar los cambios. Estas gráficas permiten observar la evolución de un índice (por ejemplo, NDVI) a lo largo del tiempo, destacando puntos de inflexión, como incendios o inundaciones. Visualizar los resultados no solo permite identificar cambios, sino que también facilita la comunicación de los hallazgos. Los mapas temáticos y las gráficas son herramientas de comunicación visual esenciales en informes técnicos y presentaciones. 3.1.8 8. Validación y verificación Para garantizar que los resultados sean precisos y reproducibles, se deben validar y verificar los hallazgos. Este paso implica la comparación de los resultados con fuentes externas o datos de campo. Si se está evaluando la deforestación, se pueden utilizar imágenes de mayor resolución espacial o información obtenida de inspecciones de campo. La validación es fundamental, ya que permite corregir errores que pueden surgir por la presencia de nubes, sombras o variaciones en la reflectancia. Este paso garantiza que los resultados finales sean precisos y confiables. 3.2 Análisis multitemporal de incendios en Córdoba (2020) usando ChatGPT y Google Earth Engine En esta sección, aprenderemos a utilizar ChatGPT como asistente para desarrollar un análisis multitemporal en Google Earth Engine (GEE). El objetivo es identificar y delimitar las áreas quemadas durante los incendios forestales de Córdoba en 2020. Usaremos imágenes de la colección MODIS, que tiene una alta frecuencia temporal y permite detectar rápidamente cambios de cobertura en grandes áreas. El análisis se enfocará en tres tareas principales: Identificación de los incendios utilizando índices de vegetación como el NDVI. Creación de una máscara de incendios para delimitar las áreas afectadas. Cálculo de la superficie quemada dentro de la región de interés. 3.2.1 Objetivo general El objetivo es guiar al usuario para que desarrolle su propio script en GEE con la asistencia de ChatGPT. Para ello, utilizaremos prompts cuidadosamente diseñados para que ChatGPT genere el código y explique los pasos. 3.2.2 Instrucciones generales para los estudiantes Usar ChatGPT de forma activa: Durante la práctica, se te proporcionarán “Prompts de ejemplo” que deberás copiar y pegar en ChatGPT. Observa la respuesta generada y, si es necesario, mejora el prompt para obtener una respuesta más precisa. Construir el script paso a paso: No recibirás todo el código completo desde el inicio. Trabajarás en fragmentos de código que se irán construyendo poco a poco. Responder preguntas de evaluación: Al final, se te harán preguntas para verificar tu comprensión de los conceptos. Aquí tienes un prompt detallado y completo para definir el caso de estudio y el objetivo del análisis para ChatGPT. Este prompt está diseñado para que ChatGPT comprenda completamente el contexto, la tarea específica, los pasos a seguir y el formato de los resultados esperados. Este prompt se puede utilizar directamente en ChatGPT para obtener respuestas precisas y personalizadas para el análisis multitemporal. 3.2.3 Prompt inicial para ChatGPT Actúa como un experto en Google Earth Engine (GEE) y teledetección. Necesito realizar un análisis multitemporal para identificar las áreas afectadas por los incendios forestales que ocurrieron en la provincia de Córdoba, Argentina, entre julio y noviembre de 2020. Este análisis se llevará a cabo paso a paso y tu tarea será proporcionar código parcial y explicaciones breves en cada paso, no el código completo de una sola vez. ### Contexto general 1. Ubicación: La región de interés (ROI) es la provincia de Córdoba, Argentina, que fue gravemente afectada por incendios forestales en 2020. 2. Fechas de análisis: Necesito imágenes de dos periodos clave: - Imagen previa a los incendios: Junio de 2020 (antes del inicio de los incendios). - Imagen posterior a los incendios: Noviembre de 2020 (cuando los incendios ya habían finalizado). 3. Fuente de datos: Usaremos la colección de imágenes satelitales de MODIS (MOD09GA) debido a su alta frecuencia de captura. 4. Objetivo: Identificar y cuantificar la superficie quemada mediante el cálculo del índice de quemadura normalizada (NBR) y la diferencia de NBR (dNBR) entre las dos fechas. 5. Indicadores clave: - NBR: Índice de quemadura normalizada, calculado a partir de las bandas NIR y SWIR (para MODIS, las bandas 2 y 7, respectivamente). - dNBR: Diferencia entre el NBR antes y después del incendio. - Superficie quemada: Se consideran quemadas las áreas donde dNBR &gt; 0.66. --- ### Flujo de trabajo propuesto El análisis se realizará paso a paso y en cada paso te solicitaré que generes un fragmento de código parcial y comentado para completar la tarea. Los pasos son los siguientes: 1. Definir la región de interés (ROI): Proporciona el código para obtener la geometría de la provincia de Córdoba (Argentina) a partir de la colección FAO/GAUL. 2. Seleccionar imágenes MODIS antes y después de los incendios: Proporciona el código para seleccionar las imágenes MODIS de junio y noviembre de 2020, aplicando los filtros de región y fechas. 3. Calcular el índice NBR antes y después del incendio: Proporciona el código para calcular el NBR para las imágenes antes y después del incendio. 4. Calcular la diferencia de NBR (dNBR): Proporciona el código para calcular la diferencia de NBR (dNBR) y resaltar las áreas quemadas. 5. Crear la máscara de áreas quemadas: Proporciona el código para generar una máscara binaria que resalte las áreas donde dNBR &gt; 0.66. 6. Calcular la superficie total quemada: Proporciona el código para calcular la superficie total quemada (en hectáreas) utilizando la función reduceRegion. 7. Visualizar los resultados: Proporciona el código para visualizar las capas de NBR, dNBR y la máscara de áreas quemadas en el mapa. 8. Exportar los resultados: Proporciona el código para exportar la imagen de las áreas quemadas a Google Drive. --- ### Instrucciones adicionales - Proporcióname el código para un solo paso a la vez, y asegúrate de explicar cada línea del código. - No me proporciones todo el código de una sola vez. Quiero avanzar paso a paso para comprender cada parte. - Usa comentarios en cada línea de código para explicar el propósito de cada operación. - Al final de cada paso, indícame si hay alguna recomendación o buena práctica para optimizar el análisis. - Proporciona sugerencias para depurar o corregir errores si algo no funciona según lo esperado. --- Para comenzar, vamos a realizar el Paso 1: Definir la región de interés (ROI). Proporciona el fragmento de código para definir la región de Córdoba, Argentina, usando la colección FAO/GAUL y explica cada línea del código. 3.2.3.1 Explicación del Prompt Contexto inicial: Este prompt establece claramente la región de interés, la fuente de datos y los objetivos del análisis. Esto asegura que ChatGPT comprenda el contexto y la tarea principal desde el inicio. Estructura de los pasos: Se enumeran los pasos específicos, pero se le dice explícitamente a ChatGPT que debe entregar un solo paso a la vez. Este enfoque asegura que el usuario tenga control sobre la secuencia de instrucciones. Instrucciones claras: Se pide que el código esté comentado y explicado línea por línea, facilitando la comprensión del usuario. Se prohíbe explícitamente que ChatGPT entregue todo el código de una vez, con la intención de que el usuario aprenda y pueda reflexionar sobre cada parte antes de avanzar. 3.2.3.2 Resultado del prompt // Paso 1: Definir la región de interés (ROI) // 1. Cargar la colección de límites administrativos GAUL de FAO var gaulCollection = ee.FeatureCollection(&#39;FAO/GAUL/2015/level1&#39;); // 2. Filtrar la colección para seleccionar solo las características (regiones) de Argentina var argentina = gaulCollection.filter(ee.Filter.eq(&#39;ADM0_NAME&#39;, &#39;Argentina&#39;)); // 3. Filtrar la región de interés para obtener solo la provincia de Córdoba var cordoba = argentina.filter(ee.Filter.eq(&#39;ADM1_NAME&#39;, &#39;Córdoba&#39;)); // 4. Visualizar la región de Córdoba en el mapa para verificar que la geometría esté correcta Map.centerObject(cordoba, 8); // Centrar el mapa en Córdoba con un nivel de zoom de 8 Map.addLayer(cordoba, {color: &#39;red&#39;}, &#39;Provincia de Córdoba&#39;); // Añadir la capa de Córdoba al mapa Identifica el problema en el código y corrige el prompt si es necesario 3.2.4 Paso 1: Definir la región de interés (ROI), siguiendo la metodología paso a paso. 3.2.4.1 Prompt para ChatGPT - Paso 1 Para comenzar con el análisis, necesito definir la región de interés (ROI) correspondiente a la provincia de Córdoba, Argentina. Usa la colección de FAO/GAUL para obtener la geometría de Córdoba y proporciona el código paso a paso. Explica cada línea de código y agrega comentarios dentro del código para facilitar la comprensión. Copia el resultado del prompt y pegalo en GEE. Luego dale RUN al script. Evalua los resultados. 3.2.4.2 Respuesta esperada de ChatGPT // Paso 1: Definir la región de interés (ROI) // 1. Cargar la colección de límites administrativos GAUL de FAO (nivel 1 - provincias/estados) var gaulCollection = ee.FeatureCollection(&#39;FAO/GAUL/2015/level1&#39;); // 2. Filtrar la colección para seleccionar solo las entidades correspondientes a Argentina var argentina = gaulCollection.filter(ee.Filter.eq(&#39;ADM0_NAME&#39;, &#39;Argentina&#39;)); // 3. Filtrar la región de interés para obtener solo la provincia de Cordoba (sin tilde) var cordoba = argentina.filter(ee.Filter.eq(&#39;ADM1_NAME&#39;, &#39;Cordoba&#39;)); // 4. Visualizar la región de Córdoba en el mapa para verificar la geometría Map.centerObject(cordoba, 8); // Centrar el mapa en Córdoba con un nivel de zoom de 8 Map.addLayer(cordoba, {color: &#39;red&#39;}, &#39;Provincia de Córdoba&#39;); // Añadir la capa de Córdoba al mapa en color rojo // 5. Usar la función print() para mostrar la información de la variable gaulCollection print(&#39;Colección de límites administrativos GAUL (Argentina):&#39;, argentina); // 6. Usar la función print() para mostrar la información de la geometría de Córdoba Explicación esperada: - Se usa la colección FAO/GAUL/2015/level1 para obtener la geometría de Córdoba. - Se aplica un filtro para seleccionar la provincia de Córdoba. - Se usa Map.centerObject y Map.addLayer para centrar la vista en la ROI y visualizarla en rojo. - Observa que en la Consola (Console) aparece la siguiente informacion como respuesta a la función print. Colección de límites administrativos GAUL (Argentina): FeatureCollection FAO/GAUL/2015/level1 (24 elements, 11 columns) type: FeatureCollection id: FAO/GAUL/2015/level1 version: 1701682593235039 columns: Object (11 properties) features: List (24 elements) properties: Object (1 property) Puedes usar esta información en ChatGPT para que te explique en qué consiste este FeatureCollection 3.2.5 Paso 2: Seleccionar imágenes MODIS antes y después de los incendios Este paso se enfoca en la obtención de las imágenes satelitales MODIS necesarias para el análisis. Se seleccionarán imágenes antes y después de los incendios forestales de Córdoba, con fechas clave de junio de 2020 (antes) y noviembre de 2020 (después). Las imágenes se filtrarán por fecha y por la región de interés (ROI) previamente definida. Además, se calculará la mediana de las imágenes para reducir el ruido en los datos. Necesito seleccionar imágenes MODIS de la colección MODIS/061/MCD43A4 para analizar incendios en Córdoba, Argentina, en 2020. Sin embargo, el área procesada y visualizada debe limitarse estrictamente al ROI definido (provincia de Córdoba). Proporciona el código para filtrar las fechas y recortar las imágenes seleccionadas al ROI utilizando la función `clip`. 1. Usa las fechas del 1 al 16 de junio de 2020 (antes del incendio) y del 16 al 30 de noviembre de 2020 (después del incendio). 2. Aplica un recorte explícito de las imágenes al ROI después de seleccionarlas y procesarlas. 3. Proporciona el código comentado línea por línea para que pueda entender el propósito de cada operación. 4. Visualiza las imágenes recortadas al ROI y verifica si están limitadas correctamente. Acción del estudiante: Copia el prompt en ChatGPT, observa la respuesta y ejecuta el código en GEE. Asegúrate de comprender cada paso antes de avanzar. 3.2.5.1 Respuesta esperada de ChatGPT // Paso 2: Selección de imágenes MODIS y recorte al ROI // 1. Cargar la colección de imágenes MODIS MCD43A4 var modisCollection = ee.ImageCollection(&#39;MODIS/061/MCD43A4&#39;); // 2. Definir las fechas de interés var preFireStart = &#39;2020-06-01&#39;; // Fecha de inicio para la imagen previa al incendio var preFireEnd = &#39;2020-06-16&#39;; // Fecha de fin para la imagen previa al incendio var postFireStart = &#39;2020-11-16&#39;; // Fecha de inicio para la imagen posterior al incendio var postFireEnd = &#39;2020-11-30&#39;; // Fecha de fin para la imagen posterior al incendio // 3. Filtrar la colección MODIS para el período previo al incendio var preFireImage = modisCollection .filterDate(preFireStart, preFireEnd) // Filtrar por fechas .filterBounds(cordoba) // Limitar la selección a la región de Córdoba .mean() // Promediar las imágenes dentro de este período de tiempo .clip(cordoba); // Recortar la imagen al área de la provincia de Córdoba // 4. Filtrar la colección MODIS para el período posterior al incendio var postFireImage = modisCollection .filterDate(postFireStart, postFireEnd) // Filtrar por fechas .filterBounds(cordoba) // Limitar la selección a la región de Córdoba .mean() // Promediar las imágenes dentro de este período de tiempo .clip(cordoba); // Recortar la imagen al área de la provincia de Córdoba // 5. Visualizar las imágenes recortadas al ROI para asegurarse de que estén bien limitadas Map.centerObject(cordoba, 8); // Centrar el mapa en la región de Córdoba Map.addLayer(preFireImage, {bands: [&#39;Nadir_Reflectance_Band1&#39;, &#39;Nadir_Reflectance_Band4&#39;, &#39;Nadir_Reflectance_Band3&#39;], min: 0, max: 3000}, &#39;Pre-Fire Image (Jun 2020)&#39;); Map.addLayer(postFireImage, {bands: [&#39;Nadir_Reflectance_Band1&#39;, &#39;Nadir_Reflectance_Band4&#39;, &#39;Nadir_Reflectance_Band3&#39;], min: 0, max: 3000}, &#39;Post-Fire Image (Nov 2020)&#39;); // 6. Usar la función print() para inspeccionar las propiedades de las imágenes print(&#39;Imagen previa al incendio (Pre-Fire):&#39;, preFireImage); print(&#39;Imagen posterior al incendio (Post-Fire):&#39;, postFireImage); 3.2.5.2 Explicación del Código para el Paso 2: Selección de Imágenes MODIS y Recorte al ROI En este paso, se seleccionan las imágenes de MODIS correspondientes a los períodos antes y después de los incendios en Córdoba. Además, las imágenes se recortan al área de interés para asegurar que el análisis esté enfocado únicamente en la región afectada. Primero, se carga la colección de imágenes MODIS MCD43A4. Este producto ofrece compuestos de reflectancia de superficie cada 16 días, lo que lo hace adecuado para analizar cambios a lo largo del tiempo. Luego, se definen los rangos de fechas para las imágenes preincendio (junio de 2020) y postincendio (noviembre de 2020). Estas fechas se eligen en función de la cronología de los incendios. Las imágenes se filtran usando las fechas definidas y la región de Córdoba. Este filtrado asegura que solo se incluyan las imágenes relevantes para el análisis. Para reducir el ruido, las imágenes dentro de cada rango de fechas se promedian. Esto ayuda a obtener una representación más estable de las condiciones en cada período. Posteriormente, las imágenes se recortan al contorno exacto de la provincia de Córdoba utilizando la función clip(). Una vez procesadas las imágenes, se visualizan en el mapa. Las bandas seleccionadas para la visualización son Nadir_Reflectance_Band1, Nadir_Reflectance_Band4 y Nadir_Reflectance_Band3, que corresponden a una combinación RGB adecuada para interpretar visualmente los cambios en la vegetación y el suelo. Finalmente, se utiliza la función print() para inspeccionar las propiedades de las imágenes generadas. Esto permite verificar aspectos como las estadísticas de las bandas, el área cubierta y la consistencia de los datos con el ROI definido. Este paso es esencial para preparar los datos antes de calcular el índice NBR, asegurando que el análisis se realice sobre imágenes representativas y correctamente recortadas al área de estudio. 3.2.6 Paso 3: Calcular el Índice NBR (Normalized Burn Ratio) El Índice de Quemadura Normalizada (NBR) es una métrica clave para identificar áreas afectadas por incendios forestales. Este índice utiliza la relación entre las bandas NIR (infrarrojo cercano) y SWIR (infrarrojo de onda corta) para resaltar las áreas quemadas, ya que estas bandas son sensibles a los cambios en la vegetación y el suelo. En el caso de MODIS MCD43A4, las bandas necesarias para calcular el NBR son: Nadir_Reflectance_Band2 (NIR) Nadir_Reflectance_Band7 (SWIR) El NBR se calcula utilizando la fórmula: \\[ NBR = \\frac{\\text{NIR} - \\text{SWIR}}{\\text{NIR} + \\text{SWIR}} \\] Esta fórmula genera valores entre -1 y 1, donde los valores cercanos a 1 indican vegetación sana, mientras que los valores negativos o bajos reflejan áreas afectadas o no vegetadas. 3.2.6.1 Prompt para ChatGPT - Paso 3 Necesito calcular el Índice de Quemadura Normalizada (NBR) para dos imágenes MODIS: una previa y otra posterior a los incendios en Córdoba, Argentina. Usa las bandas `Nadir_Reflectance_Band2` (NIR) y `Nadir_Reflectance_Band7` (SWIR) para calcular el NBR. Proporciona el código paso a paso para calcular este índice para ambas imágenes y explícalo línea por línea. 3.2.6.2 Código Generado para el Paso 3 // Paso 3: Calcular el Índice de Quemadura Normalizada (NBR) // 1. Calcular el NBR para la imagen previa al incendio var preFireNBR = preFireImage.expression( &#39;(NIR - SWIR) / (NIR + SWIR)&#39;, // Fórmula para el cálculo de NBR { &#39;NIR&#39;: preFireImage.select(&#39;Nadir_Reflectance_Band2&#39;), // Banda NIR de MODIS &#39;SWIR&#39;: preFireImage.select(&#39;Nadir_Reflectance_Band7&#39;) // Banda SWIR de MODIS } ).rename(&#39;NBR_PreFire&#39;); // Renombrar la banda para identificarla claramente // 2. Calcular el NBR para la imagen posterior al incendio var postFireNBR = postFireImage.expression( &#39;(NIR - SWIR) / (NIR + SWIR)&#39;, // Fórmula para el cálculo de NBR { &#39;NIR&#39;: postFireImage.select(&#39;Nadir_Reflectance_Band2&#39;), // Banda NIR de MODIS &#39;SWIR&#39;: postFireImage.select(&#39;Nadir_Reflectance_Band7&#39;) // Banda SWIR de MODIS } ).rename(&#39;NBR_PostFire&#39;); // Renombrar la banda para identificarla claramente // 3. Visualizar el NBR antes y después del incendio en el mapa Map.centerObject(cordoba, 8); // Centrar el mapa en la región de Córdoba Map.addLayer(preFireNBR, {min: -1, max: 1, palette: [&#39;blue&#39;, &#39;white&#39;, &#39;green&#39;]}, &#39;NBR Antes del Incendio (Jun 2020)&#39;); Map.addLayer(postFireNBR, {min: -1, max: 1, palette: [&#39;blue&#39;, &#39;white&#39;, &#39;green&#39;]}, &#39;NBR Después del Incendio (Nov 2020)&#39;); // 4. Imprimir la información de los NBRs para inspeccionar propiedades print(&#39;NBR previo al incendio:&#39;, preFireNBR); print(&#39;NBR posterior al incendio:&#39;, postFireNBR); 3.2.6.3 Explicación del Código para el Paso 3: Calcular el Índice de Quemadura Normalizada (NBR) En este paso, se calcula el Índice de Quemadura Normalizada (NBR) para las imágenes antes y después de los incendios en Córdoba. El NBR es un índice clave para detectar cambios en la vegetación y el suelo, siendo particularmente útil para identificar áreas quemadas. La fórmula utilizada para calcular el NBR es: \\[ NBR = \\frac{\\text{NIR} - \\text{SWIR}}{\\text{NIR} + \\text{SWIR}} \\] Para este análisis, se utilizan las bandas de reflectancia de MODIS: - NIR: Nadir_Reflectance_Band2 (Infrarrojo cercano). - SWIR: Nadir_Reflectance_Band7 (Infrarrojo de onda corta). El cálculo del NBR se realiza mediante la función expression(), que permite aplicar la fórmula a cada píxel de la imagen. Este proceso se aplica por separado a las imágenes previas y posteriores al incendio. Cada resultado se renombra para identificar claramente el período correspondiente (NBR_PreFire y NBR_PostFire). Después de calcular el NBR, las imágenes se visualizan en el mapa. Para ello, se utiliza una paleta de colores: - Azul: Valores bajos (suelo desnudo, agua). - Blanco: Valores intermedios. - Verde: Valores altos (vegetación saludable). Esta representación permite interpretar visualmente las condiciones de la vegetación antes y después del evento. Finalmente, la función print() se utiliza para inspeccionar las propiedades de las imágenes NBR generadas, facilitando la validación y el control de calidad de los datos. 3.2.7 Paso 4: Calcular la Diferencia de NBR (dNBR) El siguiente paso en el análisis es calcular la diferencia de NBR (dNBR), que es esencial para identificar las áreas quemadas. El dNBR se calcula restando el NBR posterior al incendio del NBR previo al incendio. Este indicador resalta los cambios en la vegetación y el suelo debido al fuego. 3.2.7.1 Prompt: Necesito calcular la diferencia de NBR (dNBR) para identificar las áreas quemadas en Córdoba, Argentina, durante los incendios de 2020. Usa las imágenes NBR previas y posteriores al incendio calculadas en el paso anterior. Proporciona el código para: 1. Calcular el dNBR restando el NBR posterior al incendio del NBR previo. 2. Asignar un nombre claro a la nueva banda. 3. Visualizar el dNBR en el mapa usando una paleta de colores adecuada. 4. Explica cada línea del código con comentarios para entender su propósito. Copia este prompt en ChatGPT y utiliza el código generado para continuar con el análisis en GEE. Asegúrate de que la visualización en el mapa sea clara y verifica los valores generados del dNBR para interpretar las áreas quemadas. 3.2.7.2 Explicación del Código para el Paso 4: Calcular la Diferencia de NBR (dNBR) En este paso, se calcula la Diferencia de NBR (dNBR), que es una métrica clave para identificar las áreas afectadas por incendios forestales. El dNBR mide la variación en el Índice de Quemadura Normalizada (NBR) entre los períodos previos y posteriores al incendio, destacando los cambios significativos en la vegetación y el suelo. La fórmula para calcular el dNBR es: \\[ dNBR = NBR_{\\text{Pre}} - NBR_{\\text{Post}} \\] 3.2.7.3 Componentes principales del código: Cálculo del dNBR: Se utiliza la función subtract() para restar el NBR posterior del NBR previo. Esto genera una nueva imagen en la que cada píxel representa la magnitud del cambio en el NBR. Los valores altos indican áreas con mayor impacto por el incendio, mientras que los valores bajos o negativos indican áreas con pocos cambios o regeneración. Renombrar la banda: La nueva banda generada se renombra como dNBR para identificarla claramente en el análisis. Visualización en el mapa: Se agrega la imagen de dNBR al mapa con una paleta de colores específica: Azul: Valores bajos, que representan áreas sin cambios significativos. Blanco: Valores intermedios, donde hubo cambios moderados. Rojo: Valores altos, que representan áreas severamente quemadas. Inspección de propiedades: Se utiliza la función print() para explorar las propiedades de la imagen de dNBR, como el rango de valores y las estadísticas de píxeles, lo que permite verificar que el cálculo sea correcto. Este paso es crucial porque el dNBR proporciona información directa sobre la severidad y la extensión del impacto del incendio en la región de interés (ROI). Con esta información, se pueden realizar análisis más detallados, como la creación de máscaras de áreas quemadas en pasos posteriores. 3.2.8 Paso 5: Crear una Máscara de Áreas Quemadas En este paso, el objetivo es identificar las áreas quemadas utilizando la diferencia de NBR (dNBR). Esto se logra aplicando un umbral (threshold) que separe los píxeles afectados por el incendio de los que no lo están. Este umbral es clave y puede variar dependiendo de las características del área y de los datos. Por lo tanto, se invita al usuario a experimentar con diferentes valores para determinar el threshold óptimo. Quiero crear una máscara de las áreas quemadas utilizando el índice dNBR calculado previamente. Necesito un fragmento de código que me permita aplicar un umbral inicial de dNBR &gt; 0.66 para identificar áreas severamente afectadas por el incendio. También quiero que el código sea flexible, de modo que pueda probar diferentes valores de threshold para ajustar la detección. Proporciona el código comentado y explica cómo ajustar el umbral. Acción del estudiante: Copia este prompt en ChatGPT, utiliza el código generado en Google Earth Engine, y ajusta el threshold para evaluar los resultados visuales. 3.2.8.1 Código Generado para el Paso 5 // Paso 5: Crear una máscara de las áreas quemadas utilizando el umbral de dNBR // 1. Definir el umbral para la detección de áreas quemadas (puedes cambiar este valor) var threshold = 0.66; // Umbral para identificar áreas quemadas (puedes modificar este valor) // 2. Crear la máscara de áreas quemadas (1 = quemada, 0 = no quemada) var burnedAreaMask = dNBR.gt(threshold) // Comparar dNBR con el umbral .selfMask() // Ocultar píxeles que no cumplan la condición (dNBR &lt;= threshold) .rename(&#39;Burned_Areas&#39;); // Renombrar la banda resultante como &#39;Burned_Areas&#39; // 3. Visualizar la máscara de áreas quemadas en el mapa Map.centerObject(cordoba, 8); // Centrar el mapa en la región de Córdoba Map.addLayer(burnedAreaMask, {palette: [&#39;red&#39;], min: 0, max: 1}, &#39;Máscara de Áreas Quemadas (dNBR &gt; &#39; + threshold + &#39;)&#39; ); // 4. Imprimir la información de la máscara para inspeccionar sus propiedades print(&#39;Máscara de Áreas Quemadas (dNBR &gt; &#39; + threshold + &#39;):&#39;, burnedAreaMask); 3.2.8.2 Explicación del Código para el Paso 5: Crear una Máscara de Áreas Quemadas Este paso se enfoca en identificar y visualizar las áreas quemadas aplicando un umbral a la diferencia de NBR (dNBR). La máscara generada es esencial para destacar los píxeles que cumplen con el criterio de cambio significativo tras los incendios. 3.2.8.3 Concepto del Umbral (Threshold) El umbral define qué tan afectado debe estar un píxel para ser clasificado como quemado. En este ejemplo, el valor inicial de 0.66 se usa como referencia para detectar áreas severamente afectadas. El umbral puede ajustarse para incluir áreas con diferentes niveles de daño. 3.2.8.4 Componentes del Código: Definición del umbral (threshold): El valor inicial se establece en 0.66, pero el usuario tiene la flexibilidad de modificar este valor para evaluar diferentes niveles de afectación. Valores más bajos incluirán áreas con menor daño, mientras que valores más altos se enfocarán en áreas con afectación severa. Creación de la máscara binaria: La función gt(threshold) compara cada píxel de dNBR con el umbral. Los píxeles que cumplen la condición (dNBR &gt; threshold) se establecen en 1, mientras que los demás se establecen en 0. selfMask() oculta los píxeles que no cumplen la condición, lo que mejora la visualización. Renombrar la banda: Se utiliza .rename('Burned_Areas') para asignar un nombre descriptivo a la banda, facilitando su interpretación y uso posterior. Visualización de la máscara: La máscara se muestra en el mapa con una paleta roja (palette: ['red']), destacando claramente las áreas quemadas. El título de la capa incluye el valor del umbral utilizado, lo que ayuda a rastrear diferentes configuraciones durante el análisis. Validación mediante inspección: La función print() permite inspeccionar las propiedades de la máscara generada, como su extensión, estadísticas y geometría, ayudando a verificar la calidad del resultado. 3.2.8.5 Ajustes del Umbral Se invita al usuario a experimentar con diferentes valores de threshold (por ejemplo, 0.4, 0.6, 0.8) para evaluar cómo cambia la detección de áreas quemadas. Esto es crucial para optimizar la identificación de las áreas afectadas según el contexto del análisis. 3.2.8.6 Resultado Esperado La máscara generada resalta las áreas quemadas en rojo, permitiendo una interpretación visual inmediata. Este resultado prepara el camino para calcular la superficie total quemada y realizar análisis adicionales en los siguientes pasos. 3.2.9 Paso 6: Crear una Máscara de Áreas Quemadas (Eliminando Cuerpos de Agua) En este paso, se mejora la identificación de áreas quemadas excluyendo los cuerpos de agua. Esto es fundamental, ya que los cuerpos de agua pueden tener valores de dNBR que se asemejan a los de áreas quemadas, generando falsos positivos. Para resolver este problema, se creará una máscara adicional que detecte los cuerpos de agua y se utilizará para excluirlos de la máscara de áreas quemadas. 3.2.9.1 Objetivo Detectar los cuerpos de agua en la región de interés. Crear una máscara de agua y superponerla a la máscara de áreas quemadas. Generar una máscara combinada que solo contenga áreas quemadas excluyendo los cuerpos de agua. 3.2.9.2 Prompt para ChatGPT - Paso 5 (Mejorado con la exclusión de cuerpos de agua) Quiero mejorar la máscara de áreas quemadas utilizando la diferencia de NBR (dNBR). Necesito que primero identifiques los cuerpos de agua dentro de la región de interés y generes una máscara de agua. Luego, utiliza esta máscara de agua para eliminar las áreas de agua de la máscara de áreas quemadas. Proporciona el código necesario para crear la máscara de agua y combinarla con la máscara de áreas quemadas. Explica cada línea del código. Ten en cuenta que este es el código hasta aquí: // Paso 1: Definir la región de interés (ROI) // 1. Cargar la colección de límites administrativos GAUL de FAO (nivel 1 - provincias/estados) var gaulCollection = ee.FeatureCollection(&#39;FAO/GAUL/2015/level1&#39;); // 2. Filtrar la colección para seleccionar solo las entidades correspondientes a Argentina var argentina = gaulCollection.filter(ee.Filter.eq(&#39;ADM0_NAME&#39;, &#39;Argentina&#39;)); // 3. Filtrar la región de interés para obtener solo la provincia de Cordoba (sin tilde) var cordoba = argentina.filter(ee.Filter.eq(&#39;ADM1_NAME&#39;, &#39;Cordoba&#39;)); // 4. Visualizar la región de Córdoba en el mapa para verificar la geometría Map.centerObject(cordoba, 8); // Centrar el mapa en Córdoba con un nivel de zoom de 8 Map.addLayer(cordoba, {color: &#39;red&#39;}, &#39;Provincia de Córdoba&#39;); // Añadir la capa de Córdoba al mapa en color rojo // 5. Usar la función print() para mostrar la información de la variable gaulCollection print(&#39;Colección de límites administrativos GAUL (Argentina):&#39;, argentina); // 6. Usar la función print() para mostrar la información de la geometría de Córdoba print(&#39;Geometría de la Provincia de Córdoba:&#39;, cordoba); // Paso 2: Selección de imágenes MODIS y recorte al ROI // 1. Cargar la colección de imágenes MODIS MCD43A4 var modisCollection = ee.ImageCollection(&#39;MODIS/061/MCD43A4&#39;); // 2. Definir las fechas de interés var preFireStart = &#39;2020-06-01&#39;; // Fecha de inicio para la imagen previa al incendio var preFireEnd = &#39;2020-06-16&#39;; // Fecha de fin para la imagen previa al incendio var postFireStart = &#39;2020-11-16&#39;; // Fecha de inicio para la imagen posterior al incendio var postFireEnd = &#39;2020-11-30&#39;; // Fecha de fin para la imagen posterior al incendio // 3. Filtrar la colección MODIS para el período previo al incendio var preFireImage = modisCollection .filterDate(preFireStart, preFireEnd) // Filtrar por fechas .filterBounds(cordoba) // Limitar la selección a la región de Córdoba .mean() // Promediar las imágenes dentro de este período de tiempo .clip(cordoba); // Recortar la imagen al área de la provincia de Córdoba // 4. Filtrar la colección MODIS para el período posterior al incendio var postFireImage = modisCollection .filterDate(postFireStart, postFireEnd) // Filtrar por fechas .filterBounds(cordoba) // Limitar la selección a la región de Córdoba .mean() // Promediar las imágenes dentro de este período de tiempo .clip(cordoba); // Recortar la imagen al área de la provincia de Córdoba // 5. Visualizar las imágenes recortadas al ROI para asegurarse de que estén bien limitadas Map.centerObject(cordoba, 8); // Centrar el mapa en la región de Córdoba Map.addLayer(preFireImage, {bands: [&#39;Nadir_Reflectance_Band1&#39;, &#39;Nadir_Reflectance_Band4&#39;, &#39;Nadir_Reflectance_Band3&#39;], min: 0, max: 3000}, &#39;Pre-Fire Image (Jun 2020)&#39;); Map.addLayer(postFireImage, {bands: [&#39;Nadir_Reflectance_Band1&#39;, &#39;Nadir_Reflectance_Band4&#39;, &#39;Nadir_Reflectance_Band3&#39;], min: 0, max: 3000}, &#39;Post-Fire Image (Nov 2020)&#39;); // 6. Usar la función print() para inspeccionar las propiedades de las imágenes print(&#39;Imagen previa al incendio (Pre-Fire):&#39;, preFireImage); print(&#39;Imagen posterior al incendio (Post-Fire):&#39;, postFireImage); // Paso 3: Calcular el Índice de Quemadura Normalizada (NBR) // 1. Calcular el NBR para la imagen previa al incendio var preFireNBR = preFireImage.expression( &#39;(NIR - SWIR) / (NIR + SWIR)&#39;, // Fórmula para el cálculo de NBR { &#39;NIR&#39;: preFireImage.select(&#39;Nadir_Reflectance_Band2&#39;), // Banda NIR de MODIS &#39;SWIR&#39;: preFireImage.select(&#39;Nadir_Reflectance_Band7&#39;) // Banda SWIR de MODIS } ).rename(&#39;NBR_PreFire&#39;); // Renombrar la banda para identificarla claramente // 2. Calcular el NBR para la imagen posterior al incendio var postFireNBR = postFireImage.expression( &#39;(NIR - SWIR) / (NIR + SWIR)&#39;, // Fórmula para el cálculo de NBR { &#39;NIR&#39;: postFireImage.select(&#39;Nadir_Reflectance_Band2&#39;), // Banda NIR de MODIS &#39;SWIR&#39;: postFireImage.select(&#39;Nadir_Reflectance_Band7&#39;) // Banda SWIR de MODIS } ).rename(&#39;NBR_PostFire&#39;); // Renombrar la banda para identificarla claramente // 3. Visualizar el NBR antes y después del incendio en el mapa Map.centerObject(cordoba, 8); // Centrar el mapa en la región de Córdoba Map.addLayer(preFireNBR, {min: -1, max: 1, palette: [&#39;blue&#39;, &#39;white&#39;, &#39;green&#39;]}, &#39;NBR Antes del Incendio (Jun 2020)&#39;); Map.addLayer(postFireNBR, {min: -1, max: 1, palette: [&#39;blue&#39;, &#39;white&#39;, &#39;red&#39;]}, &#39;NBR Después del Incendio (Nov 2020)&#39;); // 4. Imprimir la información de los NBRs para inspeccionar propiedades print(&#39;NBR previo al incendio:&#39;, preFireNBR); print(&#39;NBR posterior al incendio:&#39;, postFireNBR); // Paso 4: Calcular la diferencia de NBR (dNBR) para identificar áreas quemadas // 1. Calcular la diferencia de NBR (dNBR) como la resta entre NBR previo y NBR posterior var dNBR = preFireNBR.subtract(postFireNBR) // Restar el NBR posterior al NBR previo .rename(&#39;dNBR&#39;); // Renombrar la banda resultante como &#39;dNBR&#39; // 2. Visualizar la dNBR en el mapa Map.centerObject(cordoba, 8); // Centrar el mapa en Córdoba con un zoom de nivel 8 Map.addLayer(dNBR, {min: -1, max: 1, palette: [&#39;blue&#39;, &#39;white&#39;, &#39;red&#39;]}, &#39;dNBR (Diferencia de NBR)&#39; ); // 3. Imprimir la información de la dNBR para inspeccionar sus propiedades print(&#39;Diferencia de NBR (dNBR):&#39;, dNBR); // Paso 5: Crear una máscara de las áreas quemadas utilizando el umbral de dNBR // 1. Definir el umbral para la detección de áreas quemadas (puedes cambiar este valor) var threshold = 0.4; // Umbral para identificar áreas quemadas (puedes modificar este valor) // 2. Crear la máscara de áreas quemadas (1 = quemada, 0 = no quemada) var burnedAreaMask = dNBR.gt(threshold) // Comparar dNBR con el umbral .selfMask() // Ocultar píxeles que no cumplan la condición (dNBR &lt;= threshold) .rename(&#39;Burned_Areas&#39;); // Renombrar la banda resultante como &#39;Burned_Areas&#39; // 3. Visualizar la máscara de áreas quemadas en el mapa Map.centerObject(cordoba, 8); // Centrar el mapa en la región de Córdoba Map.addLayer(burnedAreaMask, {palette: [&#39;red&#39;], min: 0, max: 1}, &#39;Máscara de Áreas Quemadas (dNBR &gt; &#39; + threshold + &#39;)&#39; ); // 4. Imprimir la información de la máscara para inspeccionar sus propiedades print(&#39;Máscara de Áreas Quemadas (dNBR &gt; &#39; + threshold + &#39;):&#39;, burnedAreaMask); Nota para el estudiante: A veces debemos recordarle a ChatGPT cuales han sido sus respuestas anteriores para que sea consistente con las respuestas siguientes. En este caso se incluye el código que ya ha generado para que considere cualquier modificacion que nosotros hayamos hecho 3.2.9.3 Resultado esperado // Paso 6: Identificación de cuerpos de agua y exclusión de la máscara de áreas quemadas // 1. Calcular el Índice de Agua Diferenciado Normalizado (NDWI) para identificar cuerpos de agua var ndwi = preFireImage.expression( &#39;(GREEN - NIR) / (GREEN + NIR)&#39;, // Fórmula para el cálculo de NDWI { &#39;GREEN&#39;: preFireImage.select(&#39;Nadir_Reflectance_Band4&#39;), // Banda Verde (MODIS) &#39;NIR&#39;: preFireImage.select(&#39;Nadir_Reflectance_Band2&#39;) // Banda NIR (MODIS) } ).rename(&#39;NDWI&#39;); // Renombrar la banda resultante como &#39;NDWI&#39; // 2. Definir el umbral para identificar cuerpos de agua var waterThreshold = 0.2; // Umbral para la detección de cuerpos de agua (puedes cambiar este valor) // 3. Crear la máscara de agua (1 = agua, 0 = no agua) var waterMask = ndwi.gt(waterThreshold) // Identificar píxeles de agua (NDWI &gt; 0.2) .rename(&#39;Water_Mask&#39;); // Renombrar la banda para identificarla claramente // 4. Visualizar la máscara de agua en el mapa Map.addLayer(waterMask, {palette: [&#39;blue&#39;], min: 0, max: 1}, &#39;Máscara de Cuerpos de Agua (NDWI &gt; &#39; + waterThreshold + &#39;)&#39; ); // 5. Imprimir la información de la máscara de agua print(&#39;Máscara de Agua (NDWI &gt; &#39; + waterThreshold + &#39;):&#39;, waterMask); // 6. Visualizar la máscara de áreas quemadas antes de aplicar la máscara de agua Map.addLayer(burnedAreaMask, {palette: [&#39;red&#39;], min: 0, max: 1}, &#39;Máscara de Áreas Quemadas (antes de excluir agua)&#39; ); // 7. Crear una máscara lógica que combine la máscara de áreas quemadas y la máscara de agua var refinedBurnedAreaMask = burnedAreaMask.and(waterMask.not()) // Áreas quemadas que NO están en el agua .selfMask() // Ocultar píxeles donde la condición no se cumple (quedan NoData) .rename(&#39;Refined_Burned_Areas&#39;); // Renombrar la banda para identificarla claramente // 8. Visualizar la máscara de áreas quemadas refinada (sin agua) Map.addLayer(refinedBurnedAreaMask, {palette: [&#39;red&#39;], min: 0, max: 1}, &#39;Máscara de Áreas Quemadas Refinada (sin agua)&#39; ); // 9. Imprimir la información de la máscara de áreas quemadas refinada print(&#39;Máscara de Áreas Quemadas Refinada (sin agua):&#39;, refinedBurnedAreaMask); // 10. Verificar la intersección de las áreas de agua y las áreas quemadas Map.addLayer(waterMask, {palette: [&#39;blue&#39;], min: 0, max: 1}, &#39;Máscara de Agua&#39;); Map.addLayer(dNBR, {min: -1, max: 1, palette: [&#39;blue&#39;, &#39;white&#39;, &#39;red&#39;]}, &#39;dNBR&#39;); Map.addLayer(burnedAreaMask, {palette: [&#39;red&#39;], min: 0, max: 1}, &#39;Máscara de Áreas Quemadas&#39;); 3.2.9.4 Explicación del Código para el Paso 6: Crear una Máscara de Áreas Quemadas (Eliminando Cuerpos de Agua) 1. Identificar los cuerpos de agua con NDWI El NDWI (Índice de Diferencia de Agua Normalizada) permite identificar los cuerpos de agua utilizando la relación entre la banda verde (GREEN) y la banda infrarroja cercana (NIR). La fórmula para calcular el NDWI es: \\[ NDWI = \\frac{(GREEN - NIR)}{(GREEN + NIR)} \\] En este caso, se usa la imagen previa al incendio para calcular el NDWI. La banda verde (Nadir_Reflectance_Band4) y la banda NIR (Nadir_Reflectance_Band2) se utilizan para calcular el índice. Los valores de NDWI cercanos a 1 indican agua, mientras que los valores cercanos a -1 corresponden a suelo o vegetación. Lo que hace el código: - Calcula el NDWI usando la fórmula. - Los valores de NDWI se almacenan en una nueva banda llamada NDWI. Fragmento de código: var ndwi = preFireImage.expression( &#39;(GREEN - NIR) / (GREEN + NIR)&#39;, { &#39;GREEN&#39;: preFireImage.select(&#39;Nadir_Reflectance_Band4&#39;), &#39;NIR&#39;: preFireImage.select(&#39;Nadir_Reflectance_Band2&#39;) } ).rename(&#39;NDWI&#39;); 2. Crear una máscara de agua Para diferenciar los cuerpos de agua del resto, se aplica un umbral (threshold) al NDWI. Los píxeles con valores de NDWI mayores a 0.2 se consideran agua. Lo que hace el código: - Define el umbral de agua en 0.2. - Crea una máscara que identifica los píxeles de agua con un valor de 1 (agua) y el resto con un valor de 0 (no agua). - La máscara se llama Water_Mask. Fragmento de código: var waterThreshold = 0.2; var waterMask = ndwi.gt(waterThreshold) .rename(&#39;Water_Mask&#39;); 3. Eliminar los cuerpos de agua de la máscara de áreas quemadas Ahora que se tiene la máscara de agua, se usa para quitar los cuerpos de agua de la máscara de áreas quemadas. Para hacer esto, se excluyen los píxeles de agua de la máscara de áreas quemadas. Lo que hace el código: - Usa la función and() para combinar la máscara de áreas quemadas con la máscara de agua invertida. - La función waterMask.not() invierte la máscara de agua (los píxeles de agua se convierten en 0 y los demás en 1). - Se combina la máscara de áreas quemadas con la máscara de agua invertida, eliminando los cuerpos de agua de la máscara de áreas quemadas. - La nueva máscara se llama Refined_Burned_Areas. Fragmento de código: var refinedBurnedAreaMask = burnedAreaMask.and(waterMask.not()) .selfMask() .rename(&#39;Refined_Burned_Areas&#39;); 4. Visualizar la máscara refinada Se visualiza la máscara de áreas quemadas refinada para comprobar que se han excluido correctamente los cuerpos de agua. También se muestra la máscara de agua para verificar que ambas se visualizan de forma correcta. Lo que hace el código: - Muestra la máscara de agua (en azul) para verificar la correcta identificación de los cuerpos de agua. - Muestra la máscara de áreas quemadas refinada (en rojo) para ver cómo se excluyeron los cuerpos de agua de la máscara. Fragmento de código: Map.addLayer(waterMask, {palette: [&#39;blue&#39;], min: 0, max: 1}, &#39;Máscara de Agua&#39;); Map.addLayer(refinedBurnedAreaMask, {palette: [&#39;red&#39;], min: 0, max: 1}, &#39;Máscara de Áreas Quemadas Refinada (sin agua)&#39;); 3.2.10 Paso 7: Calcular la Superficie Total Quemada Quiero calcular la superficie total quemada en Córdoba, Argentina, utilizando la máscara de áreas quemadas que excluye los cuerpos de agua. Necesito que el cálculo se realice en hectáreas (ha). Para ello, sigue estos pasos: 1. Usa la máscara de áreas quemadas refinada (Refined_Burned_Areas) que ya hemos generado. 2. Calcula la cantidad de píxeles quemados que estén dentro de la región de interés (ROI) de Córdoba. 3. Convierte esta cantidad de píxeles a hectáreas, considerando el área de cada píxel de MODIS. 4. Imprime la superficie total quemada en hectáreas. 5. Proporciona comentarios línea por línea en el código para explicar cada paso. Acción del estudiante: Copia este prompt en ChatGPT y utiliza la respuesta generada en Google Earth Engine. Verifica si la superficie total quemada se muestra correctamente en hectáreas. 3.2.10.1 Resultado esperado // Paso 7: Calcular la superficie total quemada (en hectáreas) en la región de Córdoba // 1. Definir la resolución espacial de la imagen MODIS (500 m x 500 m) var pixelArea = 500 * 500; // Cada píxel de MODIS tiene un área de 500m x 500m = 250,000 m² // 2. Convertir el área de cada píxel de m² a hectáreas (1 ha = 10,000 m²) var pixelAreaHa = pixelArea / 10000; // Convertir de metros cuadrados (m²) a hectáreas (ha) print(&#39;Área de cada píxel en hectáreas:&#39;, pixelAreaHa); // 3. Contar la cantidad de píxeles quemados dentro de la región de Córdoba var burnedAreaStats = refinedBurnedAreaMask.reduceRegion({ reducer: ee.Reducer.sum(), // Suma de los píxeles de la máscara (1 = quemado, 0 = no quemado) geometry: cordoba.geometry(), // Limitar el cálculo al área de Córdoba scale: 500, // Usar la resolución de la imagen MODIS (500 m) maxPixels: 1e13 // Permitir un número máximo de píxeles a procesar }); // 4. Extraer la cantidad de píxeles quemados de la operación reduceRegion() var burnedPixelCount = ee.Number(burnedAreaStats.get(&#39;Refined_Burned_Areas&#39;)); print(&#39;Cantidad de píxeles quemados:&#39;, burnedPixelCount); // 5. Calcular la superficie total quemada en hectáreas var burnedAreaHa = burnedPixelCount.multiply(pixelAreaHa); // Multiplicar el número de píxeles quemados por el área de cada píxel en ha print(&#39;Superficie total quemada (hectáreas):&#39;, burnedAreaHa); // 6. Visualizar la máscara de áreas quemadas refinada en el mapa Map.addLayer(refinedBurnedAreaMask, {palette: [&#39;red&#39;], min: 0, max: 1}, &#39;Máscara de Áreas Quemadas Refinada (sin agua)&#39; ); 3.2.10.2 Explicación del Código para el Paso 7: Calcular la Superficie Total Quemada En este paso, se calcula la superficie total quemada en hectáreas para la región de Córdoba, excluyendo los cuerpos de agua. Este cálculo se basa en la cantidad de píxeles que cumplen con la condición de área quemada (dNBR &gt; umbral) y la conversión de esta cantidad de píxeles a hectáreas. 1. Definir el área de un píxel en hectáreas Cada píxel de la imagen MODIS tiene una resolución de 500 x 500 metros, lo que equivale a 250,000 m² por píxel. Para convertir esta superficie a hectáreas, se utiliza la conversión estándar de 1 hectárea = 10,000 m². Fórmula: \\[ \\text{Área del píxel en hectáreas} = \\frac{500 \\times 500}{10,000} = 25 \\, \\text{ha} \\] Este valor se utiliza más adelante para calcular la superficie total quemada. 2. Contar los píxeles quemados en la región de Córdoba Para determinar cuántos píxeles representan áreas quemadas, se utiliza la función reduceRegion(). Esta función aplica un reductor, en este caso ee.Reducer.sum(), que suma todos los píxeles que cumplen con la condición de área quemada (es decir, aquellos con un valor de 1 en la máscara Refined_Burned_Areas). La operación se limita a la región de interés (ROI) de Córdoba para evitar contar píxeles fuera del área de estudio. Parámetros importantes de reduceRegion(): - reducer: Suma los valores de los píxeles dentro de la región de Córdoba. - geometry: Define la región de Córdoba para limitar el área de análisis. - scale: Define la escala de los datos (500 m en el caso de MODIS). - maxPixels: Establece la cantidad máxima de píxeles que se permite procesar para evitar errores de límite de píxeles. El resultado de reduceRegion() es un objeto con la suma de los píxeles, que se almacena en la variable burnedPixelCount. 3. Calcular la superficie total quemada Para calcular la superficie quemada, se multiplica la cantidad de píxeles quemados (burnedPixelCount) por el área de cada píxel en hectáreas (pixelAreaHa), previamente calculado. Fórmula: \\[ \\text{Superficie quemada (ha)} = \\text{Cantidad de píxeles quemados} \\times \\text{Área del píxel (ha)} \\] Este resultado se imprime en la consola de Google Earth Engine para que el usuario pueda ver la superficie total quemada. 4. Visualizar la máscara de áreas quemadas refinada Finalmente, se visualiza la máscara de áreas quemadas en el mapa. Esta máscara muestra en color rojo las áreas que se consideran quemadas. Este paso permite al usuario verificar visualmente que las áreas quemadas se encuentran correctamente delimitadas en la región de Córdoba. El mapa ayuda a confirmar que las áreas de agua han sido correctamente excluidas y que la superficie quemada se ha calculado adecuadamente. Resultado Cantidad de píxeles quemados: 8307 Superficie total quemada (hectáreas): 207.696 La imagen 3.1 muestra la mascara final con las áreas quemadas. Compara este resultado con el artículo de wikipedia y saca conclusiones. Figure 3.1: Interfaz principal de Google Earth Engine. 3.2.11 Preguntas al lector Responde las preguntas a continuación y al finalizar haz clic en Submit. Luego revisa el score para ver si las respuesta fueron correctas Loading… "],["evaluación-práctica-análisis-multitemporal-para-detectar-inundaciones-en-la-plata-2013.html", "Capítulo 4 Evaluación práctica: Análisis multitemporal para detectar inundaciones en La Plata (2013) 4.1 Objetivo: 4.2 Requisitos para la entrega: 4.3 Instrucciones: 4.4 Entregables: 4.5 Criterios de evaluación:", " Capítulo 4 Evaluación práctica: Análisis multitemporal para detectar inundaciones en La Plata (2013) 4.1 Objetivo: Los estudiantes deben realizar un análisis multitemporal en Google Earth Engine (GEE) para identificar las áreas afectadas por las inundaciones en La Plata durante abril de 2013, utilizando imágenes satelitales y técnicas de teledetección. 4.2 Requisitos para la entrega: Script en GEE: Los estudiantes deben entregar el script que implementaron en GEE, asegurándose de comentar cada línea para explicar su función. Resultados visuales: Incluya capturas de pantalla del mapa generado que muestre las áreas afectadas por las inundaciones. Informe breve: Explica los resultados obtenidos, incluyendo las limitaciones y posibles mejoras del análisis. 4.3 Instrucciones: Definir la región de interés (ROI) Define la región correspondiente a La Plata y sus alrededores usando la colección de límites administrativos (por ejemplo, FAO/GAUL o GADM). Visualiza la región en el mapa para verificar que está correctamente delimitada. Seleccionar las imágenes satelitales Usa la colección de imágenes Landsat 7. Filtra las imágenes para dos períodos: Antes del evento (marzo 2013). Durante o después del evento (abril 2013). Preprocesamiento Aplica filtros de nubosidad y recorta las imágenes a la región de interés. Realiza las correcciones atmosféricas o utiliza índices relevantes para reducir ruido. Calcular índices Calcula índices relevantes como el NDWI (Índice de Agua Diferenciado Normalizado) o el NDVI, según el tipo de imagen satelital. Analiza los cambios en los índices entre los períodos pre y post-inundación. Generar una máscara de áreas inundadas Usa un umbral en el índice calculado (por ejemplo, NDWI &gt; 0.2) para identificar áreas afectadas por agua acumulada. Excluye áreas que podrían generar falsos positivos, como cuerpos de agua permanentes. Calcular la superficie afectada Calcula la superficie total de las áreas inundadas (en hectáreas) utilizando la función reduceRegion. Visualizar y exportar los resultados Visualiza las áreas inundadas en el mapa con una paleta de colores distintiva. Exporta los resultados (imágenes procesadas o shapefiles) a Google Drive o al sistema local. 4.4 Entregables: Código comentado Subir un archivo con el script de GEE, claramente comentado. Visualizaciones Adjuntar capturas de pantalla que muestren: Región de interés (La Plata). Cambios en el índice entre períodos. Mapa final de áreas inundadas. Informe breve Resumen de los pasos realizados. Superficie total afectada por las inundaciones (en hectáreas). Limitaciones del análisis y sugerencias para futuros estudios. 4.5 Criterios de evaluación: Corrección del código (40%): Uso adecuado de las funciones de GEE y estructura lógica del script. Interpretación de resultados (30%): Calidad de las visualizaciones y explicación de los resultados. Creatividad y análisis crítico (20%): Identificación de limitaciones y propuestas de mejora. Presentación (10%): Claridad en los comentarios del script, capturas y organización del informe. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
